## 一、概述

在JavaScript中，所谓字符串就是包含在英文“**双引号**”或‘**单引号**’中的内容，可以是数字、运算符号、各国语言、特殊编码字符，甚至还能是HTML的标签。也就是说，只要符合在双引号或单引号中这个要求，计算机文本中的内容基本上都可以成为一个字符串，ES6新引入了模板字符串，使用反引号（**`**）标识。



## 二、字符串引号使用规则

在使用字符串的引号时需要注意，如果一个字符串已经使用过引号，若再在字符串内使用引号需要使用另外一个引号。即双引号内使用单引号，单引号内使用双引号，或者使用转义符 `\` 对同样的引号进行转换，多层引号嵌套，该规则同样适用，如：

```javascript
var str1 = "Hello, I'm Petter!";
var str2 = 'How do you think about "JavaScript"?';
var str3 = "设置字体的'颜色'代码是：<p style=\"color:red;\">";	
```

需要了解的一个字符串常识就是，字符串不能直接分成多行去写，否则浏览器会报错。如果字符串过长，需要进行换行使视觉层次上更加地清晰，那需要这样去写：

```javascript
var str = "这是一个" + 
          "分行写的" +
          "字符串";
console.log(str); // 输出：这是一个分行写的字符串
```



## 三、字符串与数组

`parseInt()` 和 `parseFloat()` 方法可以将字符串转换为数值，同时也能对数组元素中的第一个元素进行数值转化。这说明在某种程度上，字符串和数组是有一点联系的。实际上，数组拥有的很多属性，字符串也同样具备。来看这样一个输出例子：

```javascript
var str = 'ABCDE';
var arr = ['A', 'B', 'C', 'D', 'E'];

console.log(str.length); // 5
console.log(arr.length); // 5
```

通过上例可以清晰地发现，字符串和数组是何等的相似。实际上，数组和字符串是可以互相转换的，这就需要用到两个方法：`split()` 和 `join()`：

### 3.1 split()

split() 方法用于把一个 **字符串** 分割成 **字符串数组** 。

[^ tips]: split() 方法不改变原始字符串。

```javascript
stringObject.split(separator,howmany)
```

| 参数      | 描述                                                         |
| :-------- | :----------------------------------------------------------- |
| separator | 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 |
| howmany   | 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 |

```javascript
var result;
var str = "HTML,CSS,JavaScript,jQuery";

result = str.split();
console.log(result); // ["HTML,CSS,JavaScript,jQuery"]

result = str.split(',');
console.log(result); // ["HTML", "CSS", "JavaScript", "jQuery"]

// 如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。

result = str.split("");
console.log(result); // ["H", "T", "M", "L", ",", "C", "S", "S", ",", "J", "a", "v", "a", "S", "c", "r", "i", "p", "t", ",", "j", "Q", "u", "e", "r", "y"]
```



### 3.2 join()

join() 方法用于把数组中的所有元素转换一个字符串。

元素是通过指定的分隔符进行分隔的。

```javascript
array.join(separator)
```

| 参数        | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| *separator* | 可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 |

```javascript
var arr = ["152", "2888", "5771"];

result = arr.join();
console.log(result); // "152,2888,5771"

result = arr.join('-');
console.log(result); // "152-2888-5771"
```



## 四、转义符

反斜杠 `\` 在字符串中有特殊用途，用来表示一些特殊的字符，所以又称 **转义操作符**（简称：转义符），以下是一些常用转义符的表示法：（小括号中的值表示法为**Unicode**）

```javascript
\n（或：\u000A）用于表示：换行符

\t（或：\u0009）用于表示：制表符

\'（或：\u0027）用于表示：单引号

\"（或：\u0022）用于表示：双引号

\\（或：\u005C）用于表示：反斜杠
```

当然，转义符远不止上面列出的这些。你需要注意的是，在非特殊字符前面加上转义符 `\`，那 `\` 会被省略掉，如果需要输出 `\`，那就需要写成双斜杠 `\ \` 的形式。



## 五、UNICODE

### 5.1 字符的 Unicode 表示法

JavaScript 允许采用 `\uxxxx` 形式表示一个字符，其中 `xxxx` 表示字符的 Unicode 码点，每个Unicode码都有各自对应的字符，如  `\u00A9` 就是用于输出版权符号“©”的。

在JavaScript引擎内部，所有字符都用Unicode表示，它不仅以Unicode储存字符，还允许直接在程序中使用Unicode编号表示字符。解析代码的时候，JavaScript会 **自动识别** 一个字符是字面形式表示，还是Unicode形式表示。输出给用户的时候，所有字符都会转成字面形式。其实也就是说，任何JavaScript中允许的字符都是可以通过Unicode来表示的。

```javascript
"\u5e72\u7684\u6f02\u4eae\u000d\u000a"
// 干的漂亮
```

我们还需要知道，每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。因此，`\uxxxx` 这种表示法只限于码点在`\u0000`~`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

```javascript
"\u20BB7" // "₻7"
"\uD842\uDFB7" // "𠮷" 
```

上面代码表示，如果直接在`\u`后面跟上超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript会理解成 `\u20BB+7`。由于 `\u20BB` 是一个不可打印字符，所以只会显示一个空格，后面跟着一个`7`。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

```javascript
"\u{20BB7}" // "𠮷"
```



### 5.2 str.charCodeAt(idx) 

charCodeAt(index) 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。

在ES5中，如果想将一个现成的字符转换为十六进制的Unicode的话，需要通过 `str.charCodeAt(idx)`方法获取字符数字编码值，其中，**str** 为原字符串，**idx**为需要获取数字编码的字符对应的下标。然后再通过 **toString(16)** 将刚才得到的数字编码值转化为一个十六进制的字符，并在这个十六进制的字符的前面拼接上 **\u**，就可以得到一个十六进制表示法的Unicode了。

```javascript
/**
 * 函数封装：将字符串转为Unicode编码
 */
Object.prototype.toUnicodeString = function(str) {
    var s = str || this.valueOf() ;
    var res = "";
    for (var i = 0; i < s.length; i++) {
        res += "\\u" + s.charCodeAt(i).toString(16);
    }
    return res;	
}
"王者荣耀".toUnicodeString(); // "\u738b\u8005\u8363\u8000"
```

但你需要注意，正如上一小节所说，JavaScript内部，字符以UTF-16的格式储存，每个字符固定为`2`个字节。对于那些需要`4`个字节储存的字符（Unicode码点大于`0xFFFF`的字符），JavaScript会认为它们是两个字符。

```javascript
var s = "𠮷";

s.length // 2

s.charAt(0) // "�"
s.charAt(1) // "�"

s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```

上面代码中，汉字**“𠮷”**（注意，这个字不是”吉祥“的”吉“）的码点是`0x20BB7`，UTF-16编码为 `0xD842 0xDFB7`（十进制为`55362 57271`），需要`4`个字节储存。对于这种`4`个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且 **charAt** 方法无法读取整个字符，**charCodeAt** 方法只能分别返回前两个字节和后两个字节的值。



### 5.3 String.fromCharCode()

在ES5中，我们可以通过`String.fromCharCode(numCode)`（这里的“numCode”为转换出的数字编码），又重新将数字编码转换为原来的字符串：

```javascript
var str = "帅";
var numCode = str.charCodeAt(0); // 24069
var oriStr  = String.fromCharCode(numCode); // "帅"
```

这个方法不能识别32位的UTF-16字符（即Unicode编号大于`0xFFFF` 的字符）。

```javas
String.fromCharCode(0x20BB7) // // "ஷ"
```



## 六、包装对象

JavaScript语言“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。

JS中共有三种包装对象：即数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。

```javascript
var v1 = new Number(10);
var v2 = new String("Hi");
var v3 = new Boolean("true");
```

上面代码根据原始类型的值，生成了三个对象，与原始值的类型不同。这用typeof运算符就可以看出来。

```javascript
typeof v1 // "object"
typeof v2 // "object"
typeof v3 // "object"
```

[^ tips]: 当上述三个对象充当构造函数时，可以将原始类型的值转换为对象；当充当普通函数时，可以将任意类型的值，转换为原始类型的值。

包装对象即对象，因此继承Object对象提供的原生方法。主要有一个方法叫`valueOf()`，这个方法的作用是返回包装对象实例对应的原始类型的值----即还原原始类型。

```javascript
v1.valueOf() // 10
```

**如何判断一个对象是内置对象还是包装对象？**

在 JavaScript中对象主要分为两大类，一类称作“**包装对象**”，一类称作“**内置对象**”。从编码角度讲，它们的区别是在使用了 `Object()` 方法后是否还全等于自身，若不等于自身，那就是一个包装对象；若等于自身，那就是一个内置对象。

```javascript
var str = "Henrry Lee";
str === Object(str); // false 包装对象

var obj = {name: "Henrry Lee"};
obj === Object(obj); // true  内置对象
```



或者说：

它们的区别是如果使用typeof之后为“object”，那么它就是一个内置对象，否则就是包装对象。

```javascript
var str = "Henrry Lee";
typeof(str); // "string" 包装对象

var obj = {name: "Henrry Lee"};
typeof(obj); // "object"  内置对象
```



**为什么要有包装类型：**

因为原始类型的值本身不能有任何 属性和函数，放不下。